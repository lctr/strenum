///! This library holds macros which can be used to generate enums as labels
///! for fixed instances of lazily allocated literal data.
///!

/// Macro to generate numbers in constant contexts, e.g., the constant usize
/// bound in the type signature of a fixed size array.
///
#[allow(unused)]
macro_rules! plus_1 {
    ($t:tt) => { 1 };
    ($a:tt $($bs:tt)+) => {{
        1 + plus_1!($($bs)+)
    }
    };
}

#[macro_export]
macro_rules! strenum {
    (
        $name:ident
        =
        $(
            $label:ident $lit:literal
        )+
    ) => {
        /// This enum was generated by the `strenum` macro.
        /// The variants of this enum are each associated with a fixed `&str`,
        /// provided at the macro invocation site.
        ///
        /// Some really basic info.
        ///
        #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub enum $name {
            $(
                #[doc = "Enum variant with literal value `"]
                #[doc = $lit]
                #[doc = "`"]
                #[allow(dead_code)]
                $label,
            )+
        }

        #[allow(unused)]
        impl $name {
            #[inline]
            pub fn from_str(s: &str) -> Option<Self> {
                match s {
                    $($lit => {Some($name::$label)})+
                    _ => None
                }
            }

            /// Returns the literal string provided with a given variant from
            /// where it was defined.
            #[inline]
            pub fn as_str(&self) -> &str {
                match self {
                    $($name::$label => { $lit })+
                }
            }

            /// With all variants enumerated based on definition order, this
            /// returns the `usize` value corresponding to where this
            /// instance's variant lies along the sequence of variants.
            #[inline]
            pub fn as_usize(&self) -> usize {
                let mut i = 0;
                $(
                    if self == &Self::$label { return i; } else { i += 1; };
                )+
                i
            }

            #[inline]
            pub fn as_bytes(&self) -> &[u8] {
                (match self {
                    $($name::$label => { $lit })+
                }).as_bytes()
            }

            pub fn array() -> [$name; plus_1!($($label)+)] {
                [$($name::$label,)+]
            }

            /// Identifies whether a given instance has the same variant as any
            /// from a given slice of variant instances.
            #[inline]
            pub fn is_any_of(&self, others: &[$name]) -> bool {
                others.contains(self)
            }

            /// Given a string slice, identifies whether it is equal to the
            /// string literal corresponding to any of this enum's variants.
            #[inline]
            pub fn test_str(text: &str) -> bool {
                match text {
                    $($lit => { true })+
                    _ => false
                }
            }

            /// Given a slice of bytes, identifies a match against the bytes of
            /// any of this enum's variants' string literal data
            #[inline]
            pub fn same_bytes(&self, bytes: &[u8]) -> bool {
                self.as_bytes() == bytes
            }
        }


        /// The `Display` trait just writes the same string literal each
        /// variant was defined with.
        impl std::fmt::Display for $name {
             fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                let s = match self {
                    $($name::$label => { $lit })+
                };
                write!(f, "{}", s)
            }
        }

        /// Simple implementation allowing for direct conversion to the standard
        /// library's `borrow::Cow<'t, str>` type for some lifetime `'t`.
        impl<'t> From<$name> for std::borrow::Cow<'t, str> {
            fn from(label: $name) -> std::borrow::Cow<'t, str> {
                match label {
                    $($name::$label => {
                        std::borrow::Cow::from($lit)
                    })+
                }
            }
        }

        /// Every `strenum` generated enum variant dereferences to a `&str`
        impl std::ops::Deref for $name {
            type Target = str;
            fn deref(&self) -> &Self::Target {
                match self {
                    $($name::$label => { $lit })+
                }
            }
        }

        /// Tries to convert a string slice into a variant of this enum.
        /// On failure, the provided string slice is returned.
        impl<'t> std::convert::TryFrom<&'t str> for $name {
            type Error = &'t str;

            fn try_from(value: &'t str) -> Result<Self, Self::Error> {
                match value {
                    $($lit => { Ok($name::$label) })+
                    _ => { Err(value) }
                }
            }
        }

        /// Tries to convert a string into a variant of this enum.
        /// On failure, the provided string is returned in case it is to be
        /// reused.
        impl std::convert::TryFrom<String> for $name {
            type Error = String;

            fn try_from(value: String) -> Result<Self, Self::Error> {
                match value.as_str() {
                    $($lit => { Ok($name::$label) })+
                    _ => { Err(value) }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let _m = 0;
        let _n = plus_1!(x y z u v w);
        strenum! {
            Color = Red "red" Blue "blue" Green "green"
        }

        println!(
            "|Color| = {}\n|Color::Red| = {}\n|Color::Red.as_str()| = {}\n|Color::variants()| = {}",
            std::mem::size_of::<Color>(),
            std::mem::size_of_val(&Color::Red),
            std::mem::size_of_val(Color::Red.as_str()),
            std::mem::size_of_val(&Color::array())
        );
        println!("Color::Red.as_str() = {:?}", Color::Red)
    }
}
